Условия SUM(IF(…)) 
Очень замедляет! Избегайте любой ценой. Вместо SUM может быть любая другая функция расчёта.

В некоторых случаях может приводить к проблемам с работой всего сервера.

Обычно используется новичками, которые не знают как сделать лучше;
Условие IF выполняется для каждой строки в наборе данных;
Текстовые сравнения НАМНОГО медленнее, чем числовые.
Лучшие альтернативы:

Переместите условие IF в скрипт загрузки, сгенерируйте флаг (0/1);
В 99% случаев можно использовать Set Analysis (Анализ множеств);
В тех редких случаях, когда Анализ множеств не применим, умножьте на флаг;
Умножение на флаги может быть быстрее, чем Анализ множеств, если флаги хранятся в таблице фактов;
Если нет другого выхода, используйте числовое условие.
Условия IF(SUM(…)) 
При обработке вложенных IF не отсекаются ложные ветки - все выражения будут рассчитаны. Вместо SUM может быть любая другая функция расчёта.

Лучшие альтернативы:

Использование PICK(...);
Переменная, начинающаяся со знака равенства "=", с заранее определённой формулой.
Вычисляемые измерения
Чрезвычайно тяжелые! Постарайтесь избегать их.

В дополнение к тому что они тяжёлые, когда "Вычисляемые измерения" включают несколько полей, то они не позволяют объекту использовать кэш. Таким образом, медленные вычисления останутся медленными и будут повторяться, даже если результат уже был рассчитан ранее.

Лучшие альтернативы:

По возможности перенесите расчет в скрипт загрузки;
По возможности перемещайте условия из Вычисляемого измерения в Выражение (с помощью Анализа множеств) - намного быстрее.
Острова данных
Острова данных - это таблицы, которые не связаны с основной структурой данных.

Иногда разработчики используют острова дат вместо связанных календарей;
Qlik Sense должен создать мини куб для каждой диаграммы;
Вызывает декартово соединение между фактом и островом.
Лучшие альтернативы:

Если возможно, пусть все таблицы будут связанными;
Использование Анализа множеств с « Implicit Field Values » (неявными значениями полей), такими как P() и E(), может повысить производительность;
При сравнении с одной датой использование переменной оказывается быстрее, чем использование поля острова.
Острова данных "служебное" использование
"Служебные" острова данных используются для отдельных списков, таких как:

Список доступных мер;
Список доступных измерений.
Эти случаи не приводят к декартовым объединениям, но тем не менее ухудшают производительность:

Каждое новое значение в острове данных представляет новый набор данных, который в настоящее время не кэшируется;
Любая выборка из этих полей вызывает пересчёт всех диаграмм и новое кэширование.
Лучшие альтернативы:

Использование переменной оказывается быстрее, чем использование поля острова;
Перемещение объектов (Полей списков), связанных с островом данных, в альтернативное состояние помогает избежать проблемы с кешем только объекты в альтернативном состоянии пересчитываются при изменении выбора в полях острова данных.
AGGR с очень детализированными измерениями
AGGR создает виртуальную таблицу, связанную с соответствующими измерениями

Можно использовать функцию с несколькими тысячами разных значений;
Чем более детализированo измерение, тем тяжелее становится AGGR;
Агрегирование 10 млн. строк до уровня содержащего 5 млн. строк может занимать несколько минут.
Лучшие альтернативы:

Когда измерения очень детализированы, мы должны предварительно рассчитать некоторые агрегированные уровни в скрипте;
Иногда НЕТ это допустимый ответ.
Анализ множества с очень детальным списком возможных значений
Условия Анализа множеств могут быть построены таким образом, что сделают его "тяжелым".

Oчень длинный список возможных значений (сотни или тысячи значений);
Операторы IF в условиях поиска Анализа множеств;
Расширенный поиск по полю с огромным количеством уникальных значений.
Лучшие альтернативы:

Найдите способ сгруппировать предметы с общими качествами, не перечисляя их всех.
Избегайте тяжелых поисковых конструкций
По возможности перенесите расчеты в скрипт загрузки.
Слишком много объектов на странице
Когда нужно рассчитать и построить много отдельных объектов, производительность ниже, чем при таком же объеме информации, представленном в меньшем количестве больших объектов.

Каждый отдельный объект использует дополнительные ресурсы, добавляет дополнительные накладные расходы;
Одна прямая таблица с 10 KPI лучше, чем 10 отдельных диаграмм или текстовых объектов;
Минимизированные объекты не рассчитываются, однако некоторые компоненты рассчитываются при каждом клике:
Динамические заголовки;
Условия отображения;
Условия расчета.
Лучшие альтернативы:

На дашбордах, попробуйте объединить несколько текстов или индикаторов в прямые таблицы;
В чрезвычайно загруженных приложениях избегайте слишком большого количества минимизированных или скрытых объектов с вычисленными заголовками, условиями.
Количество расчетов при каждом клике
Определенные вычисления будут выполняться при каждом клике:

Переменные, которые начинаются со знака равенства "=";
Условия отображения, условия расчета.
Лучшие альтернативы:

Контролируйте количество вычисляемых переменных. Иногда лучше рассчитать переменную, когда это необходимо, а не пересчитывать ее при каждом клике.
Не перегружайте один лист множеством скрытых графиков, с условиями изображения. Разделяйте листы по мере необходимости.
Неэффективные структуры выражений
При множественном вычислении одного и того же значения затрачиваются дополнительные ресурсы.

Для повышения эффективности выражения нужно оптимизировать;
Выражения вида (A-B)/B можно представить в виде A/B-1 (пример логики процентного прироста год к году);
Минимизировать необходимость повторения расчетов;
Если необходимо добавить доп. символ, который зависит от сравнения полученной величины с нулём, можно вынести добавление данного символа в форматирование. Num(..., CHR(9650) & '#,##0.0%' & ';' & CHR(9660) & '-#,##0.0%' & ';0%') - добавит ▼ перед отрицательными знамениями, ▲ перед положительными, 0 будет без доп. символа.
Многократное использование одного и того же расчёта в одной визуализации.
Если в визуализациях одна мера является частью другой, то часть второй меры можно заменить ссылкой на первую.

Ссылаться по при помощи COLUMN(N);
Необходимо применять с осторожностью, т.к. при добавлении, удалении или скрытии столбцов формулы могут "поломаться";
Ссылаться по имени столбца
В данном случае нужно, чтобы название столбцов не совпадали с сохранёнными мерами, измерениями или полями таблиц.
Важно! Если столбец на который идёт ссылка будет скрыт, то мера со ссылкой будет рассчитана некорректно.

Типичные проблемы в моделях данных
Слишком много таблиц, слишком много ссылок;
Поля используемые в  выражениях, хранящиеся в разных таблицах;
Слишком много полей, ненужных полей;
Поля с большим количество элементов;
Ненужные значения измерений;
Разные типы данных в одном столбце;
Синтетические ключи;
Составные ключи сохранены "как есть".
Слишком много таблиц, слишком много ссылок
Слишком фрагментированные модели данных приемлемы только для небольших наборов данных;
Требуется много времени, чтобы разрешить все ссылки в режиме реального времени;
Хорошо для быстрой демонстрации или прототипа, не масштабируемо для производства.
Лучшая альтернатива:

Потратьте некоторое время на моделирование данных и преобразуйте модель в схему звезду или «более легкую» снежинку;
Маленькие таблицы (код и имя) всегда объединяйте таблицы и удаляйте ключ, когда он не нужен;
Таблицы с множеством атрибутов храните отдельно, чтобы минимизировать пространство индекса.
Поля используемые в  выражениях, хранящиеся в разных таблицах
Выражения, включающие показатели из разных таблиц, ОЧЕНЬ тяжелые.

SUM(A*B), где A и B в разных таблицах
Лучшие альтернативы:

Структуры с объединённой таблицей фактов предпочтительнее;
Убедитесь, что все поля по которым идёт расчёт хранятся в одной таблице;
В случае с флагами либо сохраняйте флаги в таблице Фактов, либо используйте Анализ множеств вместо умножения на флаг.
Слишком много полей, ненужных полей
Следует избегать загрузки полей "на всякий случай", добавлять поля по необходимости.

Поля с большим количество элементов
Понимание того, как Qlik Sense хранит данные:

Qlik Sense хранит списки уникальных значений для всех полей.
Кроме того, все таблицы хранятся "логически" с указателями на списки значений полей;
Размер каждого указателя определяется количеством различных значений в списке ( 2N должен охватывать количество различных значений);
Поля с большим количеством уникальных значений влияют на оба размера: список становится длиннее, а длина указателя увеличивается;
Поэтому следует избегать полей с чрезвычайно большим количеством элементов (много уникальных значений), либо оптимизировать их.
Идентификаторы транзакций в большинстве случаев бесполезные для аналитических целей.

Адреса, телефоны уникальны и могут быть длинными

Разделенные на 3 части номера телефонов занимают меньше памяти, чем полный номер;
Адреса, разделенные на составляющие (город, страна, индекс), занимают меньше памяти;
Для большинства приложений не добавляется аналитическая ценность.
Даты и временные метки (Timestamp)

Некоторые базы данных автоматически предоставляют полную временную метку вместо даты;
Если время не имеет значения, урежьте число с помощью floor ();
Если время имеет значение, разделите Дата и Время на два поля. Чтобы сэкономить еще больше места, рассмотрите возможность удаления Секунд или разделения Часов, Минут и Секунд на 3 отдельных поля.
Суммы с большим количеством десятичных позиций

Некоторые базы данных содержат суммы с 15 17 десятичными знаками и более;
Обычно 4 5 десятичных знаков более чем достаточно;
Сокращение чисел помогает сократить объем и уменьшить количество элементов.
Ненужные значения измерений
Обычно таблицы фактов несут большую часть "веса", а измерениями можно пренебречь.

В больших наборах данных таблицы измерений также могут становиться большими.

Загрузка полных таблиц измерений без проверки необходимости элемента может привести к ненужным затратам памяти.

Быстрая проверка в Просмотре модели данных: наведите курсор на ключевые поля и найдите поле с Долей подмножества<100%.

Решение: Сначала загрузите данные фактов, а затем используйте WHERE Exists (ключевое поле) для каждого измерения. 

Разные типы данных в одном столбце
Иногда даты, метки времени, номера хранятся в разных форматах в разных источниках.

При объединении данных используйте явные функции форматирования.

Синтетические ключи
Синтетические ключи образуются при связи таблиц по нескольким полям. Данные ключи замедляют работу приложения.

Вместо синтетических ключей необходимо использовать составные ключи.

Составные ключи сохранены "как есть"
Составные ключи  сохранены в виде строки большой длины увеличивают потребление памяти, при этом данные поля не задействованы в визуализациях.

Для сокращения размера занимаемой памяти можно использовать функции:

Аutonumber -  возвращает уникальное значение целого для каждого определенного оцененного значения expression.
Когда несколько ключевых полей преобразуются с помощью Autonumber(), результат не будет последовательным целым числом по умолчанию;
Чтобы сгенерировать несколько последовательных целочисленных ключей, присвойте каждому Autonumber необязательную квалифицирующую строку (Autonumber(expression , 'AutoID'));
Генерация ключей Autonumber может быть медленной, особенно со сцепленными (Concat) ключами;
Быстрее создать сцепленные строки в предыдущем процессе преобразования, а затем применить Autogenerate() к одному готовому полю;
Предупреждение: Можно подключить только ключи autonumber, созданные в той же загрузке данных, поскольку целое число создается согласно порядку чтения таблицы. При использовании ключей, хранящихся между загрузками данных, независимо от сортировки исходных данных, необходимо использовать функции hash128, hash160 или hash256.
Hash128 - возвращает 128-разрядный хэш сочетания значений входного выражения. Результат - строка из 22 символов.
Hash160 - возвращает 160-разрядный хэш сочетания значений входного выражения. Результат - строка из 27 символов.
Hash256 - возвращает 256-разрядный хэш сочетания значений входного выражения. Результат - строка из 43 символов.
Оператор AutoNumber - создает уникальное значение целого для каждого определенного оцененного значения поля

Позволяет использовать знаки подстановки (*) в этом случае заключите название в кавычки (AutoNumber '%*';).
Внимание: не помогает экономить память, если применён после BINARY LOAD.
Применение данных функций и оператора не решает проблему высокого количества элементов - объединенные ключевые поля будут по прежнему иметь много различных значений и требуют длинных указателей в таблице индекса.

Несколько советов по повышению производительности скрипта загрузки
Минимизируйте объем загрузки из баз данных, используя инкрементальные загрузки и файлы QVD.
Загрузите файл QVD один раз, используйте его несколько раз.
Убедитесь, что большие файлы QVD всегда загружаются «оптимизировано».
Старайтесь избегать множества операторов IF, даже в сценарии.
Старайтесь не применять JOIN к большим таблицам. Лучше много раз использовать MAPPING.
Данные полученные при помощи JOIN зачастую занимают больший объём, чем аналогичные данные полученные при помощи MAPPING или сразу загруженные SQL запросом.
Будьте осторожны с загрузкой CROSSTABLE на больших объемах данных.
